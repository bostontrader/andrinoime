<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Andrinoime by bostontrader</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Andrinoime</h1>
      <h2 class="project-tagline">An Android IME for Javascript</h2>
      <a href="https://github.com/bostontrader/andrinoime" class="btn">View on GitHub</a>
      <a href="https://github.com/bostontrader/andrinoime/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/bostontrader/andrinoime/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="executive-summary" class="anchor" href="#executive-summary" aria-hidden="true"><span class="octicon octicon-link"></span></a>Executive Summary</h1>

<p>The purpose of the <strong>AndrinoIME</strong> is to implement an input method editor (IME) for Android
devices that is customized for use in typing JavaScript source code.</p>

<h2>
<a id="what-makes-a-javascript-ime" class="anchor" href="#what-makes-a-javascript-ime" aria-hidden="true"><span class="octicon octicon-link"></span></a>What makes a JavaScript IME?</h2>

<p>There are at least four approaches to making a JavaScript friendly IME.  In descending order of
feasibility of implementation they are:</p>

<h3>
<a id="rethink-the-keyboard" class="anchor" href="#rethink-the-keyboard" aria-hidden="true"><span class="octicon octicon-link"></span></a>Rethink the keyboard</h3>

<p>If you've ever tried to deal with JavaScript source code using other IMEs, you've no
doubt encountered the frustration of finding the various symbols needed.  They are
frequently scattered across several keyboards and it can be very tedious to switch back
and forth between them.</p>

<p>However, upon close examination, it turns out that with minimal stretch-to-fit action, the digits
 and symbols can easily fit on a single keyboard, the 26 lower-case letters can fit on another,
 with a 3rd keyboard reserved for the 26 upper-case letters, while still leaving a bit of room
 for other random and required keys.</p>

<h3>
<a id="most-recently-used-symbols" class="anchor" href="#most-recently-used-symbols" aria-hidden="true"><span class="octicon octicon-link"></span></a>Most recently used symbols</h3>

<p>The <strong>AndrinoIME</strong> also provides a keyboard composed of the most recently used digits,
symbols, and letters.</p>

<h3>
<a id="keyword-suggestions" class="anchor" href="#keyword-suggestions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Keyword suggestions</h3>

<p>The <strong>AndrinoIME</strong> offers keyword suggestions, and only that.  No need for these suggestions
to get lost in the clutter of all the other words in the language.</p>

<h3>
<a id="identifier-suggestions" class="anchor" href="#identifier-suggestions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Identifier suggestions</h3>

<p>Well, maybe not keywords only.  The <strong>AndrinoIME</strong> also suggests identifiers that are
presently defined.  However, this feature will only function with software specifically
designed to communicate information about said identifiers to the IME.  Please see
  <a href="https://github.com/bostontrader/andrino"><strong>Andrino</strong></a> for an example.</p>

<h3>
<a id="statement-auto-completion" class="anchor" href="#statement-auto-completion" aria-hidden="true"><span class="octicon octicon-link"></span></a>Statement auto-completion</h3>

<p>You wish.  Maybe someday.</p>

<h2>
<a id="the-saga" class="anchor" href="#the-saga" aria-hidden="true"><span class="octicon octicon-link"></span></a>The Saga</h2>

<p>Finding suitable documentation and examples proved to be remarkably difficult.  It's
not too difficult to find the SoftKeyboard sample from the Android SDK.  Unfortunately,
it's too simple, it doesn't come with any tests, and it doesn't seem to have attracted
any developer attention in its five year lifetime.  Hence no updates.
I looked at a few other forgettable examples that were obvious knock-offs of SoftKeyboard
and they all suffered from the same issues.</p>

<p>I finally tried out the <a href="https://github.com/CyanogenMod/android_packages_inputmethods_LatinIME">CyanogenMod LatinIME</a>
This ROX! And it has lots and lots of tests to dissect and study.  The only problem is that's
a monster!  The repo is about 500mb. It has all sorts of provisions for various locales
and accessibility.  This is all fine-and-dandy you might think, until you wade into
it to figure it out.  The complexity of dealing with all of this requires a poorly-documented
Devil's brew of XML, parsers, styling, themes, locales, enumerations, and collections.  There's
 even one lump of this that's generated by other source code!</p>

<p>Individually none of these things are rocket-science.  But collectively, there are a lot of moving
parts just to make a seemingly simple keyboard!</p>

<p>In order to actually do this I've started with a handful of the Cyanogen tests and copy-n-pasted
original source code into this project, in order to get the tests to pass.  I'm freely
commenting out whatever is not tested/necessary, so this code still has a lot of that.</p>

<p>So I'm presently working on two fronts.  Can I put techniques from the Cyanogen IME to good use
on the much simpler SoftKeyboard?  SoftKeyboard presently "works" except that it's not very well
tested and it doesn't hear my suggestions when I click on them.  Can I remove enough of the
complicated bits from Cyanogen for it to be usable by me?  Cyanogen certainly looks more
promising than SoftKeyboard, except that it doesn't actually display (in its presently
incomplete condition) any useful UI.</p>

<p>Hopefully one of these will methods will eventually succeed. Stay tuned and find out.</p>

<h2>
<a id="various-particular-issues" class="anchor" href="#various-particular-issues" aria-hidden="true"><span class="octicon octicon-link"></span></a>Various Particular Issues</h2>

<h3>
<a id="the-dictionary" class="anchor" href="#the-dictionary" aria-hidden="true"><span class="octicon octicon-link"></span></a>The Dictionary</h3>

<p>One particularly scary hoop to jump through in this project was dealing with JNI.
The Dictionary writes itself to storage and also does some things with memory management
and garbage collection that the Creator saw fit to do via native code.  At first glimpse
this seemed like an unwelcome diversion bringing with it a lot of extra work.  Fortunately,
this all turned out to be easier that I expected.</p>

<h3>
<a id="how-to-get-started-with-android-studio-gradle-jni-and-the-ndk" class="anchor" href="#how-to-get-started-with-android-studio-gradle-jni-and-the-ndk" aria-hidden="true"><span class="octicon octicon-link"></span></a>How to get started with Android Studio, Gradle, JNI, and the NDK.</h3>

<p>The vast majority of Android development is done using Java.  However, there are times when
we want to access "native" code from Java.  For example, suppose you have some C or C++ code
that you want to access from your Java code.  Whether this is a good idea or not is a separate 
issue.  Assuming you've u/s/e/d/ /y/o/u/r/ /8/-/b/a/l/l/ made your informed decision and have decided to do it, let me tell share
some tips that I found useful.</p>

<p>You'll be happy to know that doing this with Android Studio and Gradle is very feasible.
As of the time of writing (Aug 2015), this apparently is a recent development and almost all other documentation
I found was for doing this with Eclipse, command line, or various contortions to make it work 
with Android Studio and Gradle.  None of that's necessary.</p>

<p>The basic drill is that you do this by using the <a href="http://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html">Java Native Interface (JNI)</a> and the 
<a href="http://developer.android.com/ndk/guides/index.html">Android Native Development Kit (NDK)</a>.  JNI is Java's spec for how Java should communicate
with not-Java and the NDK is the kit you need to connect Android/Java to JNI.  It's easy and straight forward to download and install and there are no hidden surprises here.  Start with README.txt
and nose around in /docs and see what you find.</p>

<p>One pleasant surprise is that the NDK is fully equipped with its own build tools.  I haven't
yet spelunked into the murky depths of this, but something in there can clearly compile 
C and C++ code and build the relevant .so files, even on WinXP.</p>

<p>The most useful reference that I found was this <a href="http://stackoverflow.com/questions/21096819/jni-and-gradle-in-android-studio">SO question</a> and its answers.  I had to modify the specified command line a bit (to append '.cmd') in order to get this working on my machine.  This is a wrinkle emanating from the Windows environment.</p>

<p>Note: I'm using Android Studio 1.3.1, WinXP, and com.android.tools.build:gradle:1.2.3</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/bostontrader/andrinoime">Andrinoime</a> is maintained by <a href="https://github.com/bostontrader">bostontrader</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
