{"name":"Andrinoime","tagline":"An Android IME for Javascript","body":"#Executive Summary\r\nThe purpose of the **AndrinoIME** is to implement an input method editor (IME) for Android\r\ndevices that is customized for use in typing JavaScript source code.\r\n\r\n##What makes a JavaScript IME?\r\n\r\nThere are at least four approaches to making a JavaScript friendly IME.  In descending order of\r\nfeasibility of implementation they are:\r\n\r\n###Rethink the keyboard\r\nIf you've ever tried to deal with JavaScript source code using other IMEs, you've no\r\ndoubt encountered the frustration of finding the various symbols needed.  They are\r\nfrequently scattered across several keyboards and it can be very tedious to switch back\r\nand forth between them.\r\n\r\nHowever, upon close examination, it turns out that with minimal stretch-to-fit action, the digits\r\n and symbols can easily fit on a single keyboard, the 26 lower-case letters can fit on another,\r\n with a 3rd keyboard reserved for the 26 upper-case letters, while still leaving a bit of room\r\n for other random and required keys.\r\n\r\n###Most recently used symbols\r\nThe **AndrinoIME** also provides a keyboard composed of the most recently used digits,\r\nsymbols, and letters.\r\n\r\n###Keyword suggestions\r\nThe **AndrinoIME** offers keyword suggestions, and only that.  No need for these suggestions\r\nto get lost in the clutter of all the other words in the language.\r\n\r\n###Identifier suggestions\r\nWell, maybe not keywords only.  The **AndrinoIME** also suggests identifiers that are\r\npresently defined.  However, this feature will only function with software specifically\r\ndesigned to communicate information about said identifiers to the IME.  Please see\r\n  [**Andrino**](https://github.com/bostontrader/andrino) for an example.\r\n\r\n###Statement auto-completion\r\nYou wish.  Maybe someday.\r\n\r\n##The Saga\r\n\r\nFinding suitable documentation and examples proved to be remarkably difficult.  It's\r\nnot too difficult to find the SoftKeyboard sample from the Android SDK.  Unfortunately,\r\nit's too simple, it doesn't come with any tests, and it doesn't seem to have attracted\r\nany developer attention in its five year lifetime.  Hence no updates.\r\nI looked at a few other forgettable examples that were obvious knock-offs of SoftKeyboard\r\nand they all suffered from the same issues.\r\n\r\nI finally tried out the [CyanogenMod LatinIME](https://github.com/CyanogenMod/android_packages_inputmethods_LatinIME)\r\nThis ROX! And it has lots and lots of tests to dissect and study.  The only problem is that's\r\na monster!  The repo is about 500mb. It has all sorts of provisions for various locales\r\nand accessibility.  This is all fine-and-dandy you might think, until you wade into\r\nit to figure it out.  The complexity of dealing with all of this requires a poorly-documented\r\nDevil's brew of XML, parsers, styling, themes, locales, enumerations, and collections.  There's\r\n even one lump of this that's generated by other source code!\r\n\r\nIndividually none of these things are rocket-science.  But collectively, there are a lot of moving\r\nparts just to make a seemingly simple keyboard!\r\n\r\nIn order to actually do this I've started with a handful of the Cyanogen tests and copy-n-pasted\r\noriginal source code into this project, in order to get the tests to pass.  I'm freely\r\ncommenting out whatever is not tested/necessary, so this code still has a lot of that.\r\n\r\nSo I'm presently working on two fronts.  Can I put techniques from the Cyanogen IME to good use\r\non the much simpler SoftKeyboard?  SoftKeyboard presently \"works\" except that it's not very well\r\ntested and it doesn't hear my suggestions when I click on them.  Can I remove enough of the\r\ncomplicated bits from Cyanogen for it to be usable by me?  Cyanogen certainly looks more\r\npromising than SoftKeyboard, except that it doesn't actually display (in its presently\r\nincomplete condition) any useful UI.\r\n\r\nHopefully one of these will methods will eventually succeed. Stay tuned and find out.\r\n\r\n##Various Particular Issues\r\n\r\n###The Dictionary\r\n\r\nOne particularly scary hoop to jump through in this project was dealing with JNI.\r\nThe Dictionary writes itself to storage and also does some things with memory management\r\nand garbage collection that the Creator saw fit to do via native code.  At first glimpse\r\nthis seemed like an unwelcome diversion bringing with it a lot of extra work.  Fortunately,\r\nthis all turned out to be easier that I expected.\r\n\r\n### How to get started with Android Studio, Gradle, JNI, and the NDK.\r\n\r\nThe vast majority of Android development is done using Java.  However, there are times when\r\nwe want to access \"native\" code from Java.  For example, suppose you have some C or C++ code\r\nthat you want to access from your Java code.  Whether this is a good idea or not is a separate \r\nissue.  Assuming you've u/s/e/d/ /y/o/u/r/ /8/-/b/a/l/l/ made your informed decision and have decided to do it, let me tell share\r\nsome tips that I found useful.\r\n\r\nYou'll be happy to know that doing this with Android Studio and Gradle is very feasible.\r\nAs of the time of writing (Aug 2015), this apparently is a recent development and almost all other documentation\r\nI found was for doing this with Eclipse, command line, or various contortions to make it work \r\nwith Android Studio and Gradle.  None of that's necessary.\r\n\r\nThe basic drill is that you do this by using the [Java Native Interface (JNI)](http://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html) and the \r\n[Android Native Development Kit (NDK)](http://developer.android.com/ndk/guides/index.html).  JNI is Java's spec for how Java should communicate\r\nwith not-Java and the NDK is the kit you need to connect Android/Java to JNI.  It's easy and straight forward to download and install and there are no hidden surprises here.  Start with README.txt\r\nand nose around in /docs and see what you find.\r\n\r\nOne pleasant surprise is that the NDK is fully equipped with its own build tools.  I haven't\r\nyet spelunked into the murky depths of this, but something in there can clearly compile \r\nC and C++ code and build the relevant .so files, even on WinXP.\r\n\r\nThe most useful reference that I found was this [SO question](http://stackoverflow.com/questions/21096819/jni-and-gradle-in-android-studio) and its answers.  I had to modify the specified command line a bit (to append '.cmd') in order to get this working on my machine.  This is a wrinkle emanating from the Windows environment.\r\n\r\nNote: I'm using Android Studio 1.3.1, WinXP, and com.android.tools.build:gradle:1.2.3\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}